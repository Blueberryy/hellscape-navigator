/* Copyright Alexander Kromm (mmaulwurff@gmail.com) 2018
 *
 * This file is part of Hellscape Navigator.
 *
 * Hellscape Navigator is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Hellscape Navigator is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Hellscape Navigator.  If not, see <https://www.gnu.org/licenses/>.
 */

class m8f_hn_Data
{
  Array<Sector>  secretSectors;
  Array<int>     itemAreaPosX;
  Array<int>     itemAreaPosY;
  Array<int>     itemAreaPosZ;
  Array<string>  itemAreaNames;
  Array<string>  areaItems;
  Array<Actor>   areaNameMarkers;
  Array<Actor>   questPointers;

  Array<m8f_hn_Pointer> pointers;
  int pointerId;

  m8f_hn_Data init()
  {
    int nSectors = level.sectors.size();
    for (int i = 0; i < nSectors; ++i)
      {
        Sector s        = level.sectors[i];
        bool   isSecret = (s.Flags & (Sector.SECF_SECRET | Sector.SECF_WASSECRET));
        if (isSecret)
          {
            secretSectors.push(s);
          }
      }

    areaItems.push("Key");
    areaItems.push("Weapon"); // weapons
    areaItems.push("Goonades");
    areaItems.push("SPAMMineItem");
    areaItems.push("PowerupGiver"); // powerups
    areaItems.push("MegaSphere");
    areaItems.push("SoulSphere");
    areaItems.push("GreenArmor");
    areaItems.push("BlueArmor");
    areaItems.push("TBPowerupBase");
    areaItems.push("MapRevealer");
    areaItems.push("Berserk");
    areaItems.push("Speeders");
    areaItems.push("IcarusMk8");
    areaItems.push("ProtectoBand");
    areaItems.push("BigSPAMMine");
    areaItems.push("GuardBoi");
    areaItems.push("BadassGlasses");
    areaItems.push("Mapisto");
    areaItems.push("LovebirdTag");
    areaItems.push("BigScorePresent");
    areaItems.push("BackpackItem"); // backpacks
    areaItems.push("Backpack2");
    areaItems.push("BlueprintItem");
    areaItems.push("NetronianBackpack");
    areaItems.push("Big_Coin_pickup"); // other

    pointerId = 0;

    return self;
  }
}

class m8f_hn_EventHandler : EventHandler
{
  private Array<m8f_hn_BaseAreaNameSource> areaNameSources;
  private m8f_hn_Data data;
  private m8f_hn_Settings settings;

  private int     renderUpdatePeriod;
  private int     renderCounter;
  private string  areaName;
  private bool    isTitlemap;
  private int     _progress;
  private int     _oldProgress;
  private int     _initialFoundSectorsCount;

  private bool    _isFirstTick;
  private bool    _isWorldLoaded;

  // returns unique pointer id
  int AddPointer(double x, double y, int type)
  {
    ++data.pointerId;
    data.pointers.push(new("m8f_hn_Pointer").init(x, y, type, data.pointerId));

    return data.pointerId;
  }

  void RemovePointer(int id)
  {
    int nPointers = data.pointers.size();
    for (int i = 0; i < nPointers; ++i)
      {
        if (data.pointers[i].id() == id)
          {
            data.pointers.delete(i);
            break;
          }
      }
  }

  override void OnRegister()
  {
    areaNameSources.push(new("m8f_hn_SignAreaNameSource"));
    areaNameSources.push(new("m8f_hn_PlayerStartNameSource"));
    areaNameSources.push(new("m8f_hn_ItemAreaNameSource"));
    areaNameSources.push(new("m8f_hn_SectorAreaNameSource"));
    areaNameSources.push(new("m8f_hn_BaseAreaNameSource"));

    renderUpdatePeriod = 20;
    renderCounter      =  0;
    areaName           = "";

    _isWorldLoaded     = false;
  }

  override void WorldLoaded(WorldEvent e)
  {
    data       = new("m8f_hn_Data").init();
    isTitlemap = CheckTitlemap();
    settings   = new("m8f_hn_Settings").init(players[consolePlayer]);

    _progress    = 0;
    _oldProgress = 0;
    _initialFoundSectorsCount = 0;
  }

  override void WorldTick()
  {
    if (level.time == 1)
      {
        _isWorldLoaded            = true;
        _initialFoundSectorsCount = countFoundSectors();
      }

    int  updatePeriod = 35;
    bool isSkip       = (level.time % updatePeriod);

    if (!isSkip) { return; }

    int nSectors = level.sectors.size() - _initialFoundSectorsCount;
    if (nSectors == 0)
    {
      _progress = 10;
      return;
    }

    int nFoundSectors = countFoundSectors()  - _initialFoundSectorsCount;

    // leave place for unaccessible sectors
    _progress = nFoundSectors * 11 / nSectors;
    if (_progress > 10) { _progress = 10; }

    if (_oldProgress != _progress && _progress == 10)
    {
      PlayerInfo player = players[consolePlayer];
      if (CVar.GetCVar("m8f_hn_reveal_when_explored", player).GetInt())
      {
        Console.Printf("Level is explored, map is revealed.");
        player.mo.GiveInventory("MapRevealer", 1);
      }
    }

    _oldProgress = _progress;
  }

  static bool contains(String s, String substring)
  {
    return (s.IndexOf(substring) != -1);
  }

  override void WorldThingSpawned(WorldEvent e)
  {
    if (e == null) { return; }

    Actor item = e.thing;
    if (item == null) { return; }

    // detect and store area name markers
    string spawnedClassName = item.GetClassName();
    bool   isAreaNameMarker = contains(spawnedClassName, "hn_AreaNameMarker");
    if (isAreaNameMarker)
      {
        data.areaNameMarkers.push(item);
      }

    // detect and store quest markers
    bool isQuestPointer = contains(spawnedClassName, "hn_QuestPointer");
    if (isQuestPointer)
      {
        data.questPointers.push(item);
      }

    if (_isWorldLoaded) { return; }

    Inventory inv = Inventory(item);
    if (inv && inv.owner) { return; }

    int nAreaItems = data.areaItems.size();

    for (int i = 0; i < nAreaItems; ++i)
      {
        if (!(item is data.areaItems[i])) { continue; }

        data.itemAreaPosX.push(int(item.pos.x));
        data.itemAreaPosY.push(int(item.pos.y));
        data.itemAreaPosZ.push(int(item.pos.z));
        data.itemAreaNames.push(item.GetTag());
      }
  }

  override void NetworkProcess(ConsoleEvent event)
  {
    if      (event.name == "m8f_hn_remove_signs")     { removeSigns();     }
    else if (event.name == "m8f_hn_remove_decals")    { removeDecals();    }
  }

  static void removeSigns()
  {
    let   iterator = ThinkerIterator.Create("m8f_hn_Sign");
    Actor sign;
    while (sign = Actor(iterator.Next()))
      {
        sign.Destroy();
      }
  }

  static void removeDecals()
  {
    let     iterator = ThinkerIterator.Create("Thinker", Thinker.STAT_DECAL);
    Thinker dec;
    while (dec = iterator.Next())
      {
        dec.Destroy();
      }
  }

  ui string GetAreaName(m8f_hn_Data data) const
  {
    string areaName = "no area name sources found";
    int    size     = areaNameSources.size();
    for (int i = 0; i < size; ++i)
      {
        let areaNameSource = areaNameSources[i];
        if (settings.hideAutoAreaNames && areaNameSource.IsAutomatic())
          {
            continue;
          }

        areaName = areaNameSource.GetAreaName(data);
        if (areaName.Length() != 0) { break; }
      }
    return areaName;
  }

  play void SetRenderCounter(int value) const
  {
    renderCounter = value;
  }

  play void SetAreaName(string name) const
  {
    areaName = name;
  }

  static bool CheckTitlemap()
  {
    bool isTitlemap = (level.mapname == "TITLEMAP");
    return isTitlemap;
  }

  override void RenderOverlay(RenderEvent e)
  {
    if (isTitlemap) { return; }
    if (automapActive && !settings.showOnAutomap) { return; }

    PlayerInfo player              = players[consolePlayer];
    int        optionsUpdatePeriod =
      CVar.GetCVar("m8f_hn_update_period", player).GetInt();

    if (optionsUpdatePeriod == 0) { settings.read(player); }
    else if (optionsUpdatePeriod != -1
             && (level.time % optionsUpdatePeriod) == 0)
      {
        settings.read(player);
      }

    if (renderCounter >= renderUpdatePeriod)
      {
        SetAreaName(GetAreaName(data));
        SetRenderCounter(0);
      }
    else { SetRenderCounter(renderCounter + 1); }

    Font    font        = Font.GetFont("SMALLFONT");
    int     normalcolor = Font.CR_GRAY;
    double  x           = settings.xStart;
    double  y           = settings.yStart;
    double  scale       = 1.0 / settings.compassScale;
    vector3 pos         = player.mo.pos;
    double  playerAngle = player.mo.angle % 360.0;

    if (settings.showCompass)
    {
      y += drawCompass(x, y, scale, settings.compassStyle, data, pos, playerAngle);
    }

    if (settings.levelName)
      {
        y += drawTextCenter(level.levelName, normalColor, scale, x, y, font);
      }

    if (settings.showExplored)
      {
        string progress = StringStruct.Format("Explored: %d/10", _progress);
        y += drawTextCenter(progress, normalColor, scale, x, y, font);
      }

    if (settings.showAreaName && areaName.length() != 0)
      {
        y += drawTextCenter(areaName, normalColor, scale, x, y, font);
      }

    if (settings.showGridCoords)
      {
        string coords = makeGridCoordinates(pos);
        y += drawTextCenter(coords, normalColor, scale, x, y, font);
      }
  }

  ui static int round(double value)
  {
    int rounded = int(value + 0.5);
    return rounded;
  }

  ui static double clamp(double value, double min, double max)
  {
    if      (value < min) { return min;   }
    else if (value > max) { return max;   }
    else                  { return value; }
  }

  ui static double clampInt(int value, int min, int max)
  {
    if      (value < min) { return min;   }
    else if (value > max) { return max;   }
    else                  { return value; }
  }

  // What a mess.
  ui double drawCompass( double      relativeX
                       , double      relativeY
                       , double      scale
                       , int         style
                       , m8f_hn_Data data
                       , vector3     center
                       , double      angle
                       )
  {
    static const string ribbons[] =
    {
      "hncmpr1",
      "hncmpr2",
      "hncmpr3"
    };
    static const string borders[] =
    {
      "hncmpb1",
      "hncmpb2",
      "hncmpb3"
    };

    int screenWidth   = Screen.GetWidth();
    int screenHeight  = Screen.GetHeight();
    int screenMargin  = 10;

    int virtualWidth  = int(scale * screenWidth);
    int virtualHeight = int(scale * screenHeight);
    int virtualMargin = round(scale * screenMargin);

    // set clipping rectangle for the ribbon

    int baseRibbonWidth    = 100;
    int baseRibbonHeight   =  15;
    int screenRibbonWidth  = int(baseRibbonWidth  / scale);
    int screenRibbonHeight = int(baseRibbonHeight / scale);
    int screenRibbonX      = int(screenWidth  * relativeX) - screenRibbonWidth / 2;
    screenRibbonX = clampInt(screenRibbonX, screenMargin, screenWidth - screenMargin - screenRibbonWidth);
    int screenRibbonY      = round(screenHeight * relativeY);
    Screen.SetClipRect( screenRibbonX
                      , screenRibbonY
                      , screenRibbonWidth
                      , screenRibbonHeight
                      );

    // draw the black screen just to test clip rect

    /*
    TextureID black = TexMan.CheckForTexture("hntest1", TexMan.Type_Any);

    Screen.DrawTexture( black, false
                      , 0.0
                      , 0.0
                      , DTA_KeepRatio,     true
                      , DTA_VirtualWidth,  virtualWidth
                      , DTA_VirtualHeight, virtualHeight
                      );
    ///*///

    // draw the ribbon (clipped)

    TextureID ribbon         = TexMan.CheckForTexture(ribbons[style], TexMan.Type_Any);
    double    offsetByAngle  = (270.0 - angle) * 150.0 / 270.0 + 56.0; // ?
    double    virtualRibbonX = virtualWidth  * relativeX - baseRibbonWidth / 2;
    virtualRibbonX = clamp(virtualRibbonX, virtualMargin, virtualWidth - virtualMargin - baseRibbonWidth);
    double    virtualRibbonY = virtualHeight * relativeY;

    Screen.DrawTexture( ribbon, false
                      , virtualRibbonX - offsetByAngle
                      , virtualRibbonY
                      , DTA_KeepRatio,     true
                      , DTA_VirtualWidth,  virtualWidth
                      , DTA_VirtualHeight, virtualHeight
                      );

    // draw Pointers

    drawPointers( virtualRibbonX
                , virtualRibbonY
                , virtualWidth
                , virtualHeight
                , data
                , center
                , angle
                );

    // Beware! The code below is horrible!
    // Set 4 different clip rectangles and draw the whole border each time.

    // set clipping rectangle for the top part of the border

    int baseRectWidth = 2;
    int rectWidth     = round(baseRectWidth / scale);

    setClipRectAroundTop( screenRibbonX
                        , screenRibbonY
                        , screenRibbonWidth
                        , screenRibbonHeight
                        , rectWidth
                        );

    // draw border

    TextureID border = TexMan.CheckForTexture(borders[style], TexMan.Type_Any);

    double virtualBorderX = virtualRibbonX - 5.5;
    double virtualBorderY = virtualRibbonY - 5.0;

    Screen.DrawTexture( border, false
                      , virtualBorderX
                      , virtualBorderY
                      , DTA_KeepRatio,     true
                      , DTA_VirtualWidth,  virtualWidth
                      , DTA_VirtualHeight, virtualHeight
                      );

    // set clipping rectangle for the bottom part of the border

    setClipRectAroundBottom( screenRibbonX
                           , screenRibbonY
                           , screenRibbonWidth
                           , screenRibbonHeight
                           , rectWidth
                           );

    // draw border

    Screen.DrawTexture( border, false
                      , virtualBorderX
                      , virtualBorderY
                      , DTA_KeepRatio,     true
                      , DTA_VirtualWidth,  virtualWidth
                      , DTA_VirtualHeight, virtualHeight
                      );

    // set clipping rectangle for the left part of the border

    setClipRectAroundLeft( screenRibbonX
                         , screenRibbonY
                         , screenRibbonWidth
                         , screenRibbonHeight
                         , rectWidth
                         );

    // draw border

    Screen.DrawTexture( border, false
                      , virtualBorderX
                      , virtualBorderY
                      , DTA_KeepRatio,     true
                      , DTA_VirtualWidth,  virtualWidth
                      , DTA_VirtualHeight, virtualHeight
                      );

    // set clipping rectangle for the right part of the border

    setClipRectAroundRight( screenRibbonX
                          , screenRibbonY
                          , screenRibbonWidth
                          , screenRibbonHeight
                          , rectWidth
                          );

    // draw border

    Screen.DrawTexture( border, false
                      , virtualBorderX
                      , virtualBorderY
                      , DTA_KeepRatio,     true
                      , DTA_VirtualWidth,  virtualWidth
                      , DTA_VirtualHeight, virtualHeight
                      );

    // clear clipping rectangle
    Screen.ClearClipRect();

    double relativeCompassHeight = double(screenRibbonHeight) * 1.4 / screenHeight;
    return relativeCompassHeight;
  }

  // +--------------+
  // |      1       |
  // +--------------+
  // +-++--------++-+
  // |3||original||4|
  // +-++--------++-+
  // +--------------+
  // |      2       |
  // +--------------+

  ui static void SetClipRectAroundTop(int x, int y, int width, int height, int border)
  {
    Screen.SetClipRect( x - border
                      , y - border
                      , width + border * 2
                      , border
                      );
  }

  ui static void SetClipRectAroundBottom(int x, int y, int width, int height, int border)
  {
    Screen.SetClipRect( x - border
                      , y + height
                      , width + border * 2
                      , border
                      );
  }

  ui static void SetClipRectAroundLeft(int x, int y, int width, int height, int border)
  {
    Screen.SetClipRect( x - border
                      , y
                      , border
                      , height
                      );
  }

  ui static void SetClipRectAroundRight(int x, int y, int width, int height, int border)
  {
    Screen.SetClipRect( x + width
                      , y
                      , border
                      , height
                      );
  }

  ui static string makeGridCoordinates(vector3 pos)
  {
    int     x        = int(pos.x);
    int     y        = int(pos.y);
    int     gridSize = 512;
    if (x < 0) { x -= gridSize; }
    if (y < 0) { y -= gridSize; }
    string  xString  = intToStringAA(x / gridSize);
    y                = (y + 64) / gridSize;
    string  coords   = StringStruct.Format("%s %d", xString, y);
    return coords;
  }

  ui static string intToStringAA(int value)
  {
    if (value == 0) { return "A"; }

    bool negative;
    if (value >= 0) { negative = false;}
    else            { negative = true; value = -value - 1; }

    string result = "";
    while (true)
      {
        int small = value % 26;
        result    = StringStruct.Format("%c%s", 65 + small, result);
        value    /= 26;

        if (value == 0) break;
        --value;
      }

    if (negative) { result = StringStruct.Format("-%s", result); }

    return result;
  }

  ui static double drawTextCenter( string text
                                 , int    color
                                 , double scale
                                 , double x
                                 , double y
                                 , Font   font
                                 , int    xAdjustment = 0
                                 )
  {
    int    width       = int(scale * Screen.GetWidth());
    int    height      = int(scale * Screen.GetHeight());
    double stringWidth = font.StringWidth(text);
    x  = (width * x) - stringWidth / 2;
    y *= height;
    double margin = 4.0;
    if      (x < margin)                       { x = margin; }
    else if (x > width - stringWidth - margin) { x = width - stringWidth - margin; }

    Screen.DrawText( font, color, x, y, text
                   , DTA_KeepRatio,     true
                   , DTA_VirtualWidth,  width
                   , DTA_VirtualHeight, height
                   );

    return (font.GetHeight() / scale) / Screen.GetHeight();
  }

  ui void drawPointers( double x, double y, int width, int height
                      , m8f_hn_Data data, vector3 center, double playerAngle
                      )
  {
    static const string pointerTextures[] =
    {
      "hn_compass_pointer1",
      "hn_compass_pointer2",
      "hn_compass_pointer3",
      "hn_compass_pointer4",
      "hn_compass_pointer5",
      "hn_compass_pointer6"
    };

    int nPointers = data.pointers.size();
    for (int i = 0; i < nPointers; ++i)
    {
      double    xPointer   = data.pointers[i].x();
      double    yPointer   = data.pointers[i].y();
      int       type       = data.pointers[i].type();
      TextureID pointerTex = TexMan.CheckForTexture(pointerTextures[type], TexMan.Type_Any);

      drawPointer( x, y, width, height
                 , center, playerAngle
                 , xPointer, yPointer, pointerTex
                 , false
                 );
    }

    int nQuestPointers = data.questPointers.size();
    for (int i = 0; i < nQuestPointers; ++i)
    {
      double    xPointer   = data.questPointers[i].pos.x;
      double    yPointer   = data.questPointers[i].pos.y;
      TextureID pointerTex = TexMan.CheckForTexture( pointerTextures[m8f_hn_Pointer.POINTER_GOLD]
                                                   , TexMan.Type_Any
                                                   );

      drawPointer( x, y, width, height
                 , center, playerAngle
                 , xPointer, yPointer, pointerTex
                 , false
                 );
    }

    if (settings.showSwitches)
    {
      int nLines = level.lines.size();
      for (int i = 0; i < nLines; ++i)
      {
        Line l = level.lines[i];
        if (!isSwitch(l)) { continue; }

        double    xPointer   = (l.v1.p.x + l.v2.p.x) / 2;
        double    yPointer   = (l.v1.p.y + l.v2.p.y) / 2;
        TextureID pointerTex = TexMan.CheckForTexture( pointerTextures[m8f_hn_Pointer.POINTER_ICE]
                                                     , TexMan.Type_Any
                                                     );

        drawPointer( x, y, width, height
                   , center, playerAngle
                   , xPointer, yPointer, pointerTex
                   , true
                   );
      }
    }
  }

  ui static bool isSwitch(Line l)
  {
    bool activation = (l.activation & ( SPAC_Use
                                      | SPAC_Impact
                                      | SPAC_Push
                                      | SPAC_UseThrough
                                      | SPAC_UseBack
                                      ));
    return (activation);
  }

  ui static void drawPointer( double x, double y, int width, int height
                            , vector3 center, double playerAngle
                            , double xPointer, double yPointer, TextureID pointerTex
                            , bool closeFormula
                            )
  {

    double xDiff = xPointer - center.x;
    double yDiff = yPointer - center.y;
    double angle;
    if      (yDiff > 0.0) { angle = atan(xDiff / yDiff) +  90.0; }
    else if (yDiff < 0.0) { angle = atan(xDiff / yDiff) + 270.0; }
    else if (xDiff < 0.0) { angle =   0.0; }
    else if (xDiff > 0.0) { angle = 180.0; }
    else                  { angle =  90.0; }

    angle         = (angle + playerAngle - 90.0) % 360.0;
    double xStart = angle * 150.0 / 270.0;

    double yOffset;
    if (closeFormula)
    {
      double distance = sqrt(xDiff * xDiff + yDiff * yDiff);
      yOffset         = log(distance * 0.05) * 5 - 5;

    }
    else
    {
      double distance = xDiff * xDiff + yDiff * yDiff;
      double step     = 500000.0;
      double steps    = distance / step;
      yOffset         = steps;
      if (yOffset > 11) { yOffset = 11; } // 11 - maximum
    }

    Screen.DrawTexture( pointerTex, false, x + xStart, y + yOffset
                      , DTA_KeepRatio,     true
                      , DTA_VirtualWidth,  width
                      , DTA_VirtualHeight, height
                      );
  }

  static int countFoundSectors()
  {
    int foundSectors = 0;
    int nSectors     = level.sectors.size();

    for (int i = 0; i < nSectors; ++i)
      {
        Sector s       = level.sectors[i];
        bool   isFound = (s.MoreFlags & Sector.SECMF_DRAWN);
        if (isFound) { ++foundSectors; }
      }

    return foundSectors;
  }

} // m8f_hn_EventHandler
