class m8f_hn_Data
{
  Array<Sector>  secretSectors;
  Array<int>     itemAreaPosX;
  Array<int>     itemAreaPosY;
  Array<int>     itemAreaPosZ;
  Array<string>  itemAreaNames;
  Array<string>  areaItems;

  m8f_hn_Data init()
  {
    int nSectors = level.sectors.size();
    for (int i = 0; i < nSectors; ++i)
      {
        Sector s        = level.sectors[i];
        bool   isSecret = (s.Flags & (Sector.SECF_SECRET | Sector.SECF_WASSECRET));
        if (isSecret)
          {
            secretSectors.push(s);
          }
      }

    areaItems.push("Key");
    areaItems.push("Weapon"); // weapons
    areaItems.push("Goonades");
    areaItems.push("SPAMMineItem");
    areaItems.push("PowerupGiver"); // powerups
    areaItems.push("MegaSphere");
    areaItems.push("SoulSphere");
    areaItems.push("GreenArmor");
    areaItems.push("BlueArmor");
    areaItems.push("TBPowerupBase");
    areaItems.push("MapRevealer");
    areaItems.push("Berserk");
    areaItems.push("Speeders");
    areaItems.push("IcarusMk8");
    areaItems.push("ProtectoBand");
    areaItems.push("BigSPAMMine");
    areaItems.push("GuardBoi");
    areaItems.push("BadassGlasses");
    areaItems.push("Mapisto");
    areaItems.push("LovebirdTag");
    areaItems.push("BigScorePresent");
    areaItems.push("BackpackItem"); // backpacks
    areaItems.push("Backpack2");
    areaItems.push("BlueprintItem");
    areaItems.push("NetronianBackpack");
    areaItems.push("Big_Coin_pickup"); // other

    return self;
  }
}

class m8f_hn_EventHandler : EventHandler
{
  vector3 oldPos;
  bool    left;
  Array<m8f_hn_BaseAreaNameSource> areaNameSources;
  m8f_hn_Data data;
  int    renderUpdatePeriod;
  int    renderCounter;
  string areaName;
  bool   isWorldLoaded;
  bool   isFirstTick;
  bool   isTitlemap;
  m8f_hn_Settings settings;

  override void OnRegister()
  {
    left   = false;
    areaNameSources.push(new("m8f_hn_SignAreaNameSource"));
    areaNameSources.push(new("m8f_hn_PlayerStartNameSource"));
    areaNameSources.push(new("m8f_hn_ItemAreaNameSource"));
    areaNameSources.push(new("m8f_hn_SectorAreaNameSource"));
    areaNameSources.push(new("m8f_hn_BaseAreaNameSource"));

    renderUpdatePeriod = 20;
    renderCounter      =  0;
    areaName           = "";
    isWorldLoaded      = false;
    isFirstTick        = true;
  }

  override void WorldLoaded(WorldEvent e)
  {
    data       = new("m8f_hn_Data").init();
    isTitlemap = CheckTitlemap();
    settings   = new("m8f_hn_Settings").init(players[consolePlayer]);
  }

  override void WorldThingSpawned(WorldEvent e)
  {
    if (isWorldLoaded) { return; }
    if (e == null)     { return; }

    Actor item = e.thing;
    if (item == null) { return; }

    Inventory inv = Inventory(item);
    if (inv && inv.owner) { return; }

    int nAreaItems = data.areaItems.size();

    for (int i = 0; i < nAreaItems; ++i)
      {
        if (!(item is data.areaItems[i])) { continue; }

        data.itemAreaPosX.push(item.pos.x);
        data.itemAreaPosY.push(item.pos.y);
        data.itemAreaPosZ.push(item.pos.z);
        data.itemAreaNames.push(item.GetTag());
      }
  }

  override void WorldTick()
  {
    makeFootstepMarks();
  }

  void makeFootstepMarks()
  {
    if (settings.markerType == settings.MARKER_OFF) { return; }
    if (level.time % settings.footstepPeriod != 0)  { return; }

    if (!isFirstTick) { isWorldLoaded = true; }
    isFirstTick = false;

    PlayerInfo player      = players[consolePlayer];
    Actor      playerActor = player.mo;
    vector3    pos         = playerActor.pos;
    if (oldPos == pos) { return; }

    float xdiff = oldPos.x - pos.x;
    float ydiff = oldPos.y - pos.y;
    float dist  = xdiff * xdiff + ydiff * ydiff;
    if (dist < 400) { return; }

    oldPos = pos;

    string markerClass;
    switch (settings.markerType)
      {
      case settings.MARKER_FOOTSTEP:
        {
          float  angle  = playerActor.angle;
          string letter = AngleLetter(angle);
          markerClass   = left ? "m8f_hn_FadingLeft" : "m8f_hn_FadingRight";
          markerClass.AppendFormat(letter);
          left = !left;
        }
        break;

      case settings.MARKER_CIRCLE:
        markerClass = "m8f_hn_FadingCircle";
        break;

      case settings.MARKER_ARROW:
        {
          float  angle  = playerActor.angle;
          string letter = AngleLetter(angle);
          markerClass   = "m8f_hn_FadingArrow";
          markerClass.AppendFormat(letter);
        }
        break;
      }

    let marker = Actor.Spawn(markerClass, pos);
    m8f_hn_FadingMarker(marker).init(settings.markerLifetime,
                                     settings.markerAlpha,
                                     settings.markerForever,
                                     settings.markerScale);
  }

  override void NetworkProcess(ConsoleEvent event)
  {
    if      (event.name == "m8f_hn_remove_signs")     { removeSigns();     }
    else if (event.name == "m8f_hn_remove_decals")    { removeDecals();    }
    else if (event.name == "m8f_hn_remove_footsteps") { removeFootsteps(); }
  }

  static void removeSigns()
  {
    let   iterator = ThinkerIterator.Create("m8f_hn_Sign");
    Actor sign;
    while (sign = Actor(iterator.Next()))
      {
        sign.Destroy();
      }
  }

  static void removeDecals()
  {
    let     iterator = ThinkerIterator.Create("Thinker", Thinker.STAT_DECAL);
    Thinker dec;
    while (dec = iterator.Next())
      {
        dec.Destroy();
      }
  }

  static void removeFootsteps()
  {
    let   iterator = ThinkerIterator.Create("m8f_hn_FadingMarker");
    Actor sign;
    while (sign = Actor(iterator.Next()))
      {
        sign.Destroy();
      }
  }

  ui string GetAreaName(m8f_hn_Data data)
  {
    string areaName = "no area name sources found";
    int    size     = areaNameSources.size();
    for (int i = 0; i < size; ++i)
      {
        areaName = areaNameSources[i].GetAreaName(data);
        if (areaName.Length() != 0) { break; }
      }
    return areaName;
  }

  play void SetRenderCounter(int value) const
  {
    renderCounter = value;
  }

  play void SetAreaName(string name) const
  {
    areaName = name;
  }

  bool CheckTitlemap()
  {
    bool isTitlemap = (level.mapname == "TITLEMAP");
    return isTitlemap;
  }

  override void RenderOverlay(RenderEvent e)
  {
    if (isTitlemap) { return; }
    if (automapActive && !settings.showOnAutomap) { return; }

    PlayerInfo player              = players[consolePlayer];
    int        optionsUpdatePeriod =
      CVar.GetCVar("m8f_hn_update_period", player).GetInt();

    if (optionsUpdatePeriod == 0) { settings.read(player); }
    else if (optionsUpdatePeriod != -1
             && (level.time % optionsUpdatePeriod) == 0)
      {
        settings.read(player);
      }

    if (renderCounter >= renderUpdatePeriod)
      {
        SetAreaName(GetAreaName(data));
        SetRenderCounter(0);
      }
    else { SetRenderCounter(renderCounter + 1); }

    Font   font        = Font.GetFont("SMALLFONT");
    int    normalcolor = Font.CR_GRAY;
    double y           = int(Screen.GetHeight() * settings.yStart);
    double lineHeight  = Font.GetHeight();

    if (settings.showCompass)
    {
      y += drawCompass(y);
    }

    if (settings.levelName)
      {
        drawTextCenter(level.levelName, normalColor, 1.0, y, font);
        y += lineHeight;
      }

    if (areaName.length() != 0)
      {
        drawTextCenter(areaName, normalColor, 1.0, y, font);
        y += lineHeight;
      }

    if (settings.showGridCoords)
      {
        vector3 pos    = players[consolePlayer].mo.pos;
        string  coords = makeGridCoordinates(pos);
        drawTextCenter(coords, normalColor, 1.0, y, font);
      }
  }

  ui static double drawCompass(double y)
  {
    double    x      = Screen.GetWidth() / 2.0;
    double    angle  = players[consolePlayer].mo.angle % 360.0;
    TextureID eswn   = TexMan.CheckForTexture("compass",  TexMan.Type_Any);
    TextureID border = TexMan.CheckForTexture("compassb", TexMan.Type_Any);
    double    xStart = (270.0 - angle) * 150.0 / 270.0 + 56.0;
    double    compX  = x - 102.0 / 2.0;
    Screen.SetClipRect(compX + 1, y + 1, 100, 15);
    Screen.DrawTexture(eswn, false, compX - xStart + 1.0, y + 1);
    Screen.ClearClipRect();
    Screen.DrawTexture(border, false, compX, y);

    return 20.0;
  }

  ui static string makeGridCoordinates(vector3 pos)
  {
    int     x        = pos.x;
    int     y        = pos.y;
    int     gridSize = 512;
    if (x < 0) { x -= gridSize; }
    if (y < 0) { y -= gridSize; }
    string  xString  = intToStringAA(x / gridSize);
    y                = (y + 64) / gridSize;
    string  coords   = StringStruct.Format("%s %d", xString, y);
    return coords;
  }

  ui static string intToStringAA(int value)
  {
    if (value == 0) { return "A"; }

    bool negative;
    if (value >= 0) { negative = false;}
    else            { negative = true; value = -value - 1; }

    string result = "";
    while (true)
      {
        int small = value % 26;
        result    = StringStruct.Format("%c%s", 65 + small, result);
        value    /= 26;

        if (value == 0) break;
        --value;
      }

    if (negative) { result = StringStruct.Format("-%s", result); }

    return result;
  }

  ui static void drawTextCenter(string text, int color, double scale, double y,
                                Font font, int xAdjustment = 0)
  {
    int    width    = scale * Screen.GetWidth();
    int    height   = scale * (Screen.GetHeight() - font.GetHeight());
    int    position = width - font.StringWidth(text);
    double x        = position * 0.5 + xAdjustment;

    Screen.DrawText(font, color, x, y, text,
                    DTA_KeepRatio,     true,
                    DTA_VirtualWidth,  width,
                    DTA_VirtualHeight, height);
  }

  static string AngleLetter(float angle)
  {
    static const string letters[] =
      {
        "3", "A", "2", "9", "1", "G", "8", "F",
        "7", "E", "6", "D", "5", "C", "4", "B"
      };

    angle += 45.0 / 4;
    angle %= 360.0;
    return letters[angle / 22.5];
  }

} // m8f_hn_EventHandler
