version "3.2.0"

class m8f_hn_FadingMarker : MapMarker
{
  Default
    {
      RenderStyle "Translucent";
      XScale 0.04;
      YScale 0.04;
    }

  float fadeStep;

  m8f_hn_FadingMarker init(int lifetime)
  {
    fadeStep = 1.0 / lifetime;
    return self;
  }

  override void Tick()
  {
    alpha -= fadeStep;
    if (alpha <= 0.0) { Destroy(); }
  }

  States
    {
    Spawn:
      HNF1 A -1;
      Stop;
    }
}

class m8f_hn_FadingLeft1 : m8f_hn_FadingMarker {States{ Spawn: HNL1 A -1; Stop; }}
class m8f_hn_FadingLeft2 : m8f_hn_FadingMarker {States{ Spawn: HNL2 A -1; Stop; }}
class m8f_hn_FadingLeft3 : m8f_hn_FadingMarker {States{ Spawn: HNL3 A -1; Stop; }}
class m8f_hn_FadingLeft4 : m8f_hn_FadingMarker {States{ Spawn: HNL4 A -1; Stop; }}
class m8f_hn_FadingLeft5 : m8f_hn_FadingMarker {States{ Spawn: HNL5 A -1; Stop; }}
class m8f_hn_FadingLeft6 : m8f_hn_FadingMarker {States{ Spawn: HNL6 A -1; Stop; }}
class m8f_hn_FadingLeft7 : m8f_hn_FadingMarker {States{ Spawn: HNL7 A -1; Stop; }}
class m8f_hn_FadingLeft8 : m8f_hn_FadingMarker {States{ Spawn: HNL8 A -1; Stop; }}
class m8f_hn_FadingLeft9 : m8f_hn_FadingMarker {States{ Spawn: HNL9 A -1; Stop; }}
class m8f_hn_FadingLeftA : m8f_hn_FadingMarker {States{ Spawn: HNLA A -1; Stop; }}
class m8f_hn_FadingLeftB : m8f_hn_FadingMarker {States{ Spawn: HNLB A -1; Stop; }}
class m8f_hn_FadingLeftC : m8f_hn_FadingMarker {States{ Spawn: HNLC A -1; Stop; }}
class m8f_hn_FadingLeftD : m8f_hn_FadingMarker {States{ Spawn: HNLD A -1; Stop; }}
class m8f_hn_FadingLeftE : m8f_hn_FadingMarker {States{ Spawn: HNLE A -1; Stop; }}
class m8f_hn_FadingLeftF : m8f_hn_FadingMarker {States{ Spawn: HNLF A -1; Stop; }}
class m8f_hn_FadingLeftG : m8f_hn_FadingMarker {States{ Spawn: HNLG A -1; Stop; }}

class m8f_hn_FadingRight1 : m8f_hn_FadingMarker {States{ Spawn: HNR1 A -1; Stop; }}
class m8f_hn_FadingRight2 : m8f_hn_FadingMarker {States{ Spawn: HNR2 A -1; Stop; }}
class m8f_hn_FadingRight3 : m8f_hn_FadingMarker {States{ Spawn: HNR3 A -1; Stop; }}
class m8f_hn_FadingRight4 : m8f_hn_FadingMarker {States{ Spawn: HNR4 A -1; Stop; }}
class m8f_hn_FadingRight5 : m8f_hn_FadingMarker {States{ Spawn: HNR5 A -1; Stop; }}
class m8f_hn_FadingRight6 : m8f_hn_FadingMarker {States{ Spawn: HNR6 A -1; Stop; }}
class m8f_hn_FadingRight7 : m8f_hn_FadingMarker {States{ Spawn: HNR7 A -1; Stop; }}
class m8f_hn_FadingRight8 : m8f_hn_FadingMarker {States{ Spawn: HNR8 A -1; Stop; }}
class m8f_hn_FadingRight9 : m8f_hn_FadingMarker {States{ Spawn: HNR9 A -1; Stop; }}
class m8f_hn_FadingRightA : m8f_hn_FadingMarker {States{ Spawn: HNRA A -1; Stop; }}
class m8f_hn_FadingRightB : m8f_hn_FadingMarker {States{ Spawn: HNRB A -1; Stop; }}
class m8f_hn_FadingRightC : m8f_hn_FadingMarker {States{ Spawn: HNRC A -1; Stop; }}
class m8f_hn_FadingRightD : m8f_hn_FadingMarker {States{ Spawn: HNRD A -1; Stop; }}
class m8f_hn_FadingRightE : m8f_hn_FadingMarker {States{ Spawn: HNRE A -1; Stop; }}
class m8f_hn_FadingRightF : m8f_hn_FadingMarker {States{ Spawn: HNRF A -1; Stop; }}
class m8f_hn_FadingRightG : m8f_hn_FadingMarker {States{ Spawn: HNRG A -1; Stop; }}

class m8f_hn_FadingArrow1 : m8f_hn_FadingMarker {States{ Spawn: HNA1 A -1; Stop; }}
class m8f_hn_FadingArrow2 : m8f_hn_FadingMarker {States{ Spawn: HNA2 A -1; Stop; }}
class m8f_hn_FadingArrow3 : m8f_hn_FadingMarker {States{ Spawn: HNA3 A -1; Stop; }}
class m8f_hn_FadingArrow4 : m8f_hn_FadingMarker {States{ Spawn: HNA4 A -1; Stop; }}
class m8f_hn_FadingArrow5 : m8f_hn_FadingMarker {States{ Spawn: HNA5 A -1; Stop; }}
class m8f_hn_FadingArrow6 : m8f_hn_FadingMarker {States{ Spawn: HNA6 A -1; Stop; }}
class m8f_hn_FadingArrow7 : m8f_hn_FadingMarker {States{ Spawn: HNA7 A -1; Stop; }}
class m8f_hn_FadingArrow8 : m8f_hn_FadingMarker {States{ Spawn: HNA8 A -1; Stop; }}
class m8f_hn_FadingArrow9 : m8f_hn_FadingMarker {States{ Spawn: HNA9 A -1; Stop; }}
class m8f_hn_FadingArrowA : m8f_hn_FadingMarker {States{ Spawn: HNAA A -1; Stop; }}
class m8f_hn_FadingArrowB : m8f_hn_FadingMarker {States{ Spawn: HNAB A -1; Stop; }}
class m8f_hn_FadingArrowC : m8f_hn_FadingMarker {States{ Spawn: HNAC A -1; Stop; }}
class m8f_hn_FadingArrowD : m8f_hn_FadingMarker {States{ Spawn: HNAD A -1; Stop; }}
class m8f_hn_FadingArrowE : m8f_hn_FadingMarker {States{ Spawn: HNAE A -1; Stop; }}
class m8f_hn_FadingArrowF : m8f_hn_FadingMarker {States{ Spawn: HNAF A -1; Stop; }}
class m8f_hn_FadingArrowG : m8f_hn_FadingMarker {States{ Spawn: HNAG A -1; Stop; }}

class m8f_hn_FadingCircle : m8f_hn_FadingMarker {States{ Spawn: HNCR A -1; Stop; }}

class m8f_hn_Data
{
  Array<Sector> secretSectors;
}

class m8f_hn_EventHandler : EventHandler
{
  int     period;
  vector3 oldPos;
  bool    left;
  Array<m8f_hn_BaseAreaNameSource> areaNameSources;
  m8f_hn_Data data;
  int    renderUpdatePeriod;
  int    renderCounter;
  string areaName;

  override void OnRegister()
  {
    period = CVar.GetCVar("m8f_hn_marker_spawn_period").GetInt();
    left   = false;
    areaNameSources.push(new("m8f_hn_SignAreaNameSource"));
    areaNameSources.push(new("m8f_hn_PlayerStartNameSource"));
    areaNameSources.push(new("m8f_hn_SectorAreaNameSource"));
    areaNameSources.push(new("m8f_hn_BaseAreaNameSource"));

    data = new("m8f_hn_Data");

    renderUpdatePeriod = 20;
    renderCounter      =  0;
    areaName           = "";
  }

  override void WorldLoaded(WorldEvent e)
  {
    int nSectors = level.sectors.size();
    for (int i = 0; i < nSectors; ++i)
      {
        Sector s        = level.sectors[i];
        bool   isSecret = (s.Flags & (Sector.SECF_SECRET | Sector.SECF_WASSECRET));
        if (isSecret)
          {
            data.secretSectors.push(s);
          }
      }
  }

  override void WorldTick()
  {
    if (level.time % period != 0) { return; }

    period         = CVar.GetCVar("m8f_hn_marker_spawn_period").GetInt();
    int lifetime   = CVar.GetCVar("m8f_hn_marker_lifetime"    ).GetInt();
    int markerType = CVar.GetCVar("m8f_hn_marker_type"        ).GetInt();

    PlayerInfo player = players[consolePlayer];
    Actor playerActor = player.mo;
    vector3 pos = playerActor.pos;
    if (playerActor && oldPos == pos) { return; }

    float xdiff = oldPos.x - pos.x;
    float ydiff = oldPos.y - pos.y;
    float dist  = xdiff * xdiff + ydiff * ydiff;
    if (dist < 400) { return; }

    oldPos = pos;

    string markerClass;
    switch (markerType)
      {
      case 0: // footsteps
        {
          float  angle  = playerActor.angle;
          string letter = AngleLetter(angle);
          markerClass   = left ? "m8f_hn_FadingLeft" : "m8f_hn_FadingRight";
          markerClass.AppendFormat(letter);
          left = !left;
        }
        break;

      case 1: // circle
        markerClass = "m8f_hn_FadingCircle";
        break;

      case 2: // arrow
        {
          float  angle  = playerActor.angle;
          string letter = AngleLetter(angle);
          markerClass   = "m8f_hn_FadingArrow";
          markerClass.AppendFormat(letter);
        }
        break;

      case 3: // off
        return;
      }

    let marker = Actor.Spawn(markerClass, pos);
    m8f_hn_FadingMarker(marker).init(lifetime);
  }

  override void NetworkProcess(ConsoleEvent event)
  {
    if (event.name == "m8f_hn_remove_signs")
      {
        let   iterator = ThinkerIterator.Create("m8f_hn_Sign");
        Actor sign;
        while (sign = Actor(iterator.Next()))
          {
            sign.Destroy();
          }
      }

    else if (event.name == "m8f_hn_remove_decals")
      {
        let     iterator = ThinkerIterator.Create("Thinker", Thinker.STAT_DECAL);
        Thinker dec;
        while (dec = iterator.Next())
          {
            dec.Destroy();
          }
      }
  }

  ui string GetAreaName(m8f_hn_Data data)
  {
    int size = areaNameSources.size();
    string areaName = "no area name sources found";
    for (int i = 0; i < size; ++i)
      {
        areaName = areaNameSources[i].GetAreaName(data);
        if (areaName.Length() != 0) { break; }
      }
    return areaName;
  }

  play void SetRenderCounter(int value) const
  {
    renderCounter = value;
  }

  play void SetAreaName(string name) const
  {
    areaName = name;
  }

  override void RenderOverlay(RenderEvent e)
  {
    if (renderCounter >= renderUpdatePeriod)
      {
        SetAreaName(GetAreaName(data));
        SetRenderCounter(0);
      }
    else { SetRenderCounter(renderCounter + 1); }

    Font   font        = Font.GetFont("SMALLFONT");
    int    normalcolor = Font.CR_GRAY;
    double x           = Screen.GetWidth() / 2;
    double y           = 10;
    drawTextCenter(areaName, normalColor, 1.0, y + 20, font);

    double    angle     = players[consolePlayer].mo.angle % 360.0;
    TextureID eswn      = TexMan.CheckForTexture("compass",  TexMan.Type_Any);
    TextureID border    = TexMan.CheckForTexture("compassb", TexMan.Type_Any);
    int       xStart    = (270.0 - angle) * 150.0 / 270.0 + 56;
    double    compX     = x - 102 / 2;
    Screen.SetClipRect(compX + 1, y + 1, 100, 15);
    Screen.DrawTexture(eswn, false, compX - xStart + 1, y + 1);
    Screen.ClearClipRect();
    Screen.DrawTexture(border, false, compX, y);
  }

  ui void drawTextCenter(string text, int color, double scale, double y,
                         Font font, int xAdjustment = 0)
  {
    int width    = scale * Screen.GetWidth();
    int height   = scale * (Screen.GetHeight() - font.GetHeight());
    int position = width - font.StringWidth(text);

    double x = position * 0.5 + xAdjustment;

    Screen.DrawText(font, color, x, y, text,
                    DTA_KeepRatio,     true,
                    DTA_VirtualWidth,  width,
                    DTA_VirtualHeight, height);
  }

  static string AngleLetter(float angle)
  {
    static const string letters[] =
      {
        "3", "A", "2", "9", "1", "G", "8", "F",
        "7", "E", "6", "D", "5", "C", "4", "B"
      };

    angle += 45.0 / 4;
    angle %= 360.0;
    return letters[angle / 22.5];
  }

} // m8f_hn_EventHandler

class m8f_hn_BaseAreaNameSource
{

  play virtual string GetAreaName(m8f_hn_Data data) const
  {
    return "";
  }

} // m8f_hn_BaseAreaNameSource

class m8f_hn_PlayerStartNameSource : m8f_hn_BaseAreaNameSource
{
  override string GetAreaName(m8f_hn_Data data)
  {
    vector3    playerStart;
    int        angle;
    [playerStart, angle]      = Object.G_PickPlayerStart(consolePlayer);
    vector3    playerPos      = players[consolePlayer].mo.pos;
    double     dx             = playerStart.x - playerPos.x;
    double     dy             = playerStart.y - playerPos.y;
    double     dz             = playerStart.z - playerPos.z;
    double     distance       = dx * dx + dy * dy + dz * dz;
    bool       isCloseToStart = (distance < 20000);

    return isCloseToStart ? "Entrance" : "";
  }
} // m8f_hn_PlayerStartNameSource

class m8f_hn_SignAreaNameSource : m8f_hn_BaseAreaNameSource
{
  override string GetAreaName(m8f_hn_Data data)
  {
    vector3     playerPos = players[consolePlayer].mo.pos;
    let         iterator  = ThinkerIterator.Create("m8f_hn_Sign");
    m8f_hn_Sign sign;
    double      minDistance = -1;
    m8f_hn_Sign closestSign = null;

    while (sign = m8f_hn_Sign(iterator.Next()))
      {
        if (sign.areaName.length() == 0) { continue; }

        vector3 signPos       = sign.pos;
        double  dx            = signPos.x - playerPos.x;
        double  dy            = signPos.y - playerPos.y;
        double  dz            = signPos.z - playerPos.z;
        double  distance      = dx * dx + dy * dy + dz * dz;

        if ((distance < minDistance || minDistance < 0.0)
            && distance < sign.areaRadius)
          {
            minDistance = distance;
            closestSign = sign;
          }
      }

    return closestSign ? closestSign.areaName : "";
  }
} // m8f_hn_SignAreaNameSource

class m8f_hn_SectorAreaNameSource : m8f_hn_BaseAreaNameSource
{
  override string GetAreaName(m8f_hn_Data data)
  {
    PlayerInfo player = players[consolePlayer];
    if (player == null) { return ""; }

    Actor playerActor = player.mo;
    if (playerActor == null) { return ""; }

    Sector currentSector = playerActor.curSector;
    if (currentSector == null) { return ""; }

    bool isSecret = (currentSector.Flags & (Sector.SECF_SECRET | Sector.SECF_WASSECRET));
    if (isSecret)
      {
        int nSecretSectors = data.secretSectors.size();
        int i = 0;
        for (; i < nSecretSectors; ++i)
          {
            if (currentSector == data.secretSectors[i]) { break; }
          }
        return StringStruct.Format("Secret #%d", i + 1);
      }

    bool isSky = (currentSector.GetTexture(1) == skyflatnum);
    if (isSky) { return "Outdoors"; }

    int nLines = currentSector.lines.size();
    for (int i = 0; i < nLines; ++i)
      {
        Line l = currentSector.lines[i];
        int  s = l.special;
        if (s == 74 || s == 75 || s == 243 || s == 244)
          {
            return "Exit";
          }
      }

    return "";
  }
} // m8f_hn_SectorAreaNameSource

class m8f_hn_Sign : Actor
{

  Default
    {
      Health 30;
      Height 10;
      +SOLID;
      +NOBLOOD;
      +NOTONAUTOMAP;
    }

  string note;
  int    spawnTime;
  Actor  marker;
  string areaName;
  double areaRadius;

  override void BeginPlay()
  {
    string line1 = CVar.GetCVar("m8f_hn_sign_note1").GetString();
    string line2 = CVar.GetCVar("m8f_hn_sign_note2").GetString();
    string line3 = CVar.GetCVar("m8f_hn_sign_note3").GetString();

    note = line1;
    if (line2.Length() != 0) { note.AppendFormat("\n%s", line2); }
    if (line3.Length() != 0) { note.AppendFormat("\n%s", line3); }

    spawnTime = level.time;
    marker    = Spawn("m8f_hn_WoodenSignMarker", pos);

    bool shootable = CVar.GetCVar("m8f_hn_sign_shootable").GetInt();
    bSHOOTABLE = shootable;

    CVar areaNameCVar = CVar.GetCVar("m8f_hn_area_name");
    areaName          = areaNameCVar.GetString();
    areaNameCVar.setString("");

    areaRadius = CVar.GetCVar("m8f_hn_area_radius").GetFloat();
    areaRadius *= areaRadius;
  }

  override bool Used(Actor user)
  {
    string text = note;
    int    sec  = Thinker.Tics2Seconds(spawnTime);
    bool   addTime = CVar.GetCVar("m8f_hn_sign_add_time").GetInt();
    if (addTime)
      {
        text.AppendFormat("\n\n        %02d:%02d:%02d",
                          sec / 3600, (sec % 3600) / 60, sec % 60);
      }
    user.A_Print(text);
    return true;
  }

  override void Die(Actor source, Actor inflictor, int dmgflags)
  {
    marker.Destroy();
    super.Die(source, inflictor, dmgflags);
  }

} // m8f_hn_Sign

class m8f_hn_WoodenSign : m8f_hn_Sign
{

  States
    {
    Spawn:
      HNWS A -1;
      Stop;
    }

} // class m8f_hn_WoodenSign

class m8f_hn_WoodenSignMarker : MapMarker
{

  Default
    {
      XScale 0.2;
      YScale 0.2;
    }

  States
    {
    Spawn:
      HNWS A -1;
      Stop;
    }

} // m8f_hn_WoodenSignMarker
